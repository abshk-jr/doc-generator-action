<html><head><title>List Comprehensions</title><link href="./styles/style.css" rel="stylesheet"/></head><body class="mw-body" style="height:auto"><h1 class="firstHeading" id="firstHeading">List Comprehensions</h1><div id="bodyContent"><table cellpadding="0" cellspacing="0" style="clear: right; margin-bottom: .5em; float: right; padding: .5em 0 .8em 1.4em; background: none; width: auto;">
<tbody><tr>
<td><div aria-labelledby="mw-toc-heading" class="toc" id="toc" role="navigation"><div class="toctitle" dir="ltr" lang="en"><h2 id="mw-toc-heading">Contents</h2></div>
<ul style="list-style-image:none">
<li><a href="#Basic_Syntax"><span class="tocnumber">1</span> Basic Syntax</a>
<ul style="list-style-image:none">
<li><a href="#multiple_generator_expressions"><span class="tocnumber">1.1</span> multiple generator expressions</a></li>
<li><a href="#for"><span class="tocnumber">1.2</span> for</a></li>
<li><a href="#each"><span class="tocnumber">1.3</span> each</a></li>
<li><a href="#if"><span class="tocnumber">1.4</span> if</a></li>
<li><a href="#if/else"><span class="tocnumber">1.5</span> if/else</a></li>
<li><a href="#let"><span class="tocnumber">1.6</span> let</a></li>
</ul>
</li>
<li><a href="#Nested_loops"><span class="tocnumber">2</span> Nested loops</a></li>
<li><a href="#Advanced_Examples"><span class="tocnumber">3</span> Advanced Examples</a>
<ul style="list-style-image:none">
<li><a href="#Generating_vertices_for_a_polygon"><span class="tocnumber">3.1</span> Generating vertices for a polygon</a></li>
<li><a href="#Flattening_a_nested_vector"><span class="tocnumber">3.2</span> Flattening a nested vector</a></li>
<li><a href="#Sorting_a_vector"><span class="tocnumber">3.3</span> Sorting a vector</a></li>
<li><a href="#Selecting_elements_of_a_vector"><span class="tocnumber">3.4</span> Selecting elements of a vector</a></li>
<li><a href="#Concatenating_two_vectors"><span class="tocnumber">3.5</span> Concatenating two vectors</a></li>
</ul>
</li>
</ul>
</div>

</td></tr></tbody></table>

<p><span style="font-weight: bold; font-style: normal;">[<span style="color: #A00000;">Note:</span> <span style="font-weight: normal; font-style: italic;">Requires version <span style="font-weight: bold;">2015.03</span></span>]</span>
</p>
<h3>Basic Syntax</h3>
<p>The list comprehensions provide a flexible way to generate lists using the general syntax
</p>
<pre> [ list-definition expression ]
</pre>
<p>The following elements are supported to construct the list definition
</p>
<dl><dt>for (i = sequence)</dt>
<dd>Iteration over a range or an existing list</dd>
<dt>for (init;condition;next)</dt>
<dd>Simple recursive call represented as C-style for</dd>
<dt>each</dt>
<dd>Takes a sequence value as argument, and adds each element to the list being constructed. each x is equivalent to  `for (i = x) i`</dd>
<dt>if (condition)</dt>
<dd>Selection criteria, when true the expression is calculated and added to the result list</dd>
<dt>let (x = value)</dt>
<dd>Local variable assignment</dd></dl>
<h4>multiple generator expressions</h4>
<p><span style="font-weight: bold; font-style: normal;">[<span style="color: #A00000;">Note:</span> <span style="font-weight: normal; font-style: italic;">Requires version <span style="font-weight: bold;">2019.05</span></span>]</span>
</p><p>The list comprehension syntax is generalized to allow multiple expressions. This allows to easily construct lists from multiple sub lists generated by different list comprehension expressions avoiding concat.
</p>
<pre>steps = 50;

points = [
	// first expression generating the points in the positive Y quadrant
	for (a = [0 : steps]) [ a, 10 * sin(a * 360 / steps) + 10 ],
	// second expression generating the points in the negative Y quadrant
	for (a = [steps : -1 : 0]) [ a, 10 * cos(a * 360 / steps) - 20 ],
	// additional list of fixed points
	[ 10, -3 ], [ 3, 0 ], [ 10, 3 ]
];

polygon(points);
</pre>
<h4>for</h4>
<p>The for element defines the input values for the list generation. The syntax is the same as used by the <a href="Conditional_and_Iterator_Functions.html#For_Loop" title="OpenSCAD User Manual/Conditional and Iterator Functions">for</a> iterator. The sequence to the right of the equals sign can be any list. The for element iterates over all the members of the list. The variable on the left of the equals sign take on the value of each member of the sequence in turn. This value can then be processed in the child of the for element, and each result becomes a member of the final list that is produced. 
</p><p>If the sequence has more than one dimension, for iterates over the first dimension only. Deeper dimensions can be accessed by nesting for elements. 
</p><p>Several common usage patterns are presented here.
</p>
<dl><dt>[ for (i = [start : step : end]) i ]</dt>
<dd>Generate output based on a range definition, this version is mainly useful to calculate list values or access existing lists using the range value as index.</dd></dl>
<p><b>Examples</b>
</p>
<pre>// generate a list with all values defined by a range
list1 = [ for (i = [0 : 2 : 10]) i ];
echo(list1); // ECHO: [0, 2, 4, 6, 8, 10]
</pre>
<pre>// extract every second character of a string
str = "SomeText";
list2 = [ for (i = [0 : 2 : len(str) - 1]) str[i] ];
echo(list2); // ECHO: ["S", "m", "T", "x"]
</pre>
<pre>// indexed list access, using function to map input values to output values
function func(x) = x &lt; 1 ? 0 : x + func(x - 1);
input = [1, 3, 5, 8];
output = [for (a = [ 0 : len(input) - 1 ]) func(input[a]) ];
echo(output); // ECHO: [1, 6, 15, 36]
</pre>
<dl><dt>[ for (i = [a, b, c, ...]) i ]</dt>
<dd>Use list parameter as input, this version can be used to map input values to calculated output values.</dd></dl>
<p><b>Examples</b>
</p>
<pre>// iterate over an existing list
friends = ["John", "Mary", "Alice", "Bob"];
list = [ for (i = friends) len(i)];
echo(list); // ECHO: [4, 4, 5, 3]
</pre>
<pre>// map input list to output list
list = [ for (i = [2, 3, 5, 7, 11]) i * i ];
echo(list); // ECHO: [4, 9, 25, 49, 121]
</pre>
<pre>// calculate Fibonacci numbers
function func(x) = x &lt; 3 ? 1 : func(x - 1) + func(x - 2);
input = [7, 10, 12];
output = [for (a = input) func(a) ];
echo(output); // ECHO: [13, 55, 144]
</pre>
<dl><dt>[ for (c = "String") c ]</dt>
<dd>Generate output based on a string, this iterates over each character of the string.</dd></dl>
<p><span style="font-weight: bold; font-style: normal;">[<span style="color: #A00000;">Note:</span> <span style="font-weight: normal; font-style: italic;">Requires version <span style="font-weight: bold;">2019.05</span></span>]</span>
</p><p><b>Examples</b>
</p>
<pre>echo([ for (c = "String") c ]);
// ECHO: ["S", "t", "r", "i", "n", "g"]
</pre>
<dl><dt>[ for (a = inita, b = initb, ...;condition;a = nexta, b = nextb, ...) expr ]</dt>
<dd>Generator for expressing simple recursive call in a c-style for loop.</dd></dl>
<p><span style="font-weight: bold; font-style: normal;">[<span style="color: #A00000;">Note:</span> <span style="font-weight: normal; font-style: italic;">Requires version <span style="font-weight: bold;">2019.05</span></span>]</span>
</p><p>The recursive equivalent of this generator is
</p>
<pre>function f(a, b, ...) =
    condition
    ? concat([expr], f(nexta, nextb, ...))
    : [];
  f(inita, initb, ...)</pre>
<p><b>Examples</b>
</p>
<pre>echo( [for (a = 0, b = 1;a &lt; 5;a = a + 1, b = b + 2) [ a, b * b ] ] );
// ECHO: [[0, 1], [1, 9], [2, 25], [3, 49], [4, 81]]

// Generate fibonacci sequence
echo([for (a = 0, b = 1;a &lt; 1000;x = a + b, a = b, b = x) a]);
// ECHO: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987]
</pre>
<h4>each</h4>
<p><span style="font-weight: bold; font-style: normal;">[<span style="color: #A00000;">Note:</span> <span style="font-weight: normal; font-style: italic;">Requires version <span style="font-weight: bold;">2019.05</span></span>]</span>
</p><p><i>each</i> embeds the values of a list given as argument directly, effectively unwrapping the argument list.
</p>
<pre>// Without using "each", a nested list is generated
echo([ for (a = [1 : 4]) [a, a * a] ]);
// ECHO: [[1, 1], [2, 4], [3, 9], [4, 16]]

// Adding "each" unwraps the inner list, producing a flat list as result
echo([ for (a = [1 : 4]) each [a, a * a] ]);
// ECHO: [1, 1, 2, 4, 3, 9, 4, 16]
</pre>
<p><i>each</i> unwraps ranges and helps to build more general <i>for</i> lists when combined with multiple generator expressions.
</p>
<pre>A = [-2, each [1:2:5], each [6:-2:0], -1];
echo([ for (a = A) 2 * a ]);
// ECHO: [-4, 2, 6, 10, 12, 8, 4, 0, -2]
</pre>
<h4>if</h4>
<p>The if element allows selection if the expression should be allocated and added to the result list or not. In the simplest case this allows filtering of an list.
</p>
<dl><dt>[ for (i = list) if (condition(i)) i ]</dt>
<dd>When the evaluation of the condition returns true, the expression i is added to the result list.</dd></dl>
<p><i>Example</i>
</p>
<pre>list = [ for (a = [ 1 : 8 ]) if (a % 2 == 0) a ];
echo(list); // ECHO: [2, 4, 6, 8]
</pre>
<p>Note that the if element cannot be inside an expression, it should be at the top.
</p><p><i>Example</i>
</p>
<pre>// from the input list include all positive odd numbers
// and also all even number divided by 2

list = [-10:5];
echo([for(n=list) if(n%2==0 || n&gt;=0) n%2==0 ? n/2 : n ]); 
// ECHO: [-5, -4, -3, -2, -1, 0, 1, 1, 3, 2, 5]
// echo([for(n=list) n%2==0 ? n/2 : if(n&gt;=0) n ]); // this would generate a syntactical error
</pre>
<h4>if/else</h4>
<p><span style="font-weight: bold; font-style: normal;">[<span style="color: #A00000;">Note:</span> <span style="font-weight: normal; font-style: italic;">Requires version <span style="font-weight: bold;">2019.05</span></span>]</span>
</p><p>The if-else construct is equivalent to the conditional expression ?: except that it can be combined with filter if. 
</p>
<dl><dt>[ for (i = list) if (condition(i)) x else y ]</dt>
<dd>When the evaluation of the condition returns true, the expression x is added to the result list else the expression y.</dd></dl>
<pre>// even numbers are halved, positive odd numbers are preserved, negative odd numbers are eliminated
echo([for (a = [-3:5]) if (a % 2 == 0) [a, a/2] else if (a &gt; 0) [a, a] ]);
// ECHO: [[-2, -1], [0, 0], [1, 1], [2, 1], [3, 3], [4, 2], [5, 5]];
</pre>
<p>Note that in the expression above the conditional operator could not substitute if-else. It is possible to express this same filter with the conditional operator but with a more cryptic logic:
</p>
<pre>// even numbers are halved, positive odd numbers are preserved, negative odd numbers are eliminated
echo([for (a = [-3:5]) if (a % 2 == 0 || (a % 2 != 0 &amp;&amp; a &gt; 0)) a % 2 == 0 ? [a, a / 2] : [a, a] ]);
// ECHO: [[-2, -1], [0, 0], [1, 1], [2, 1], [3, 3], [4, 2], [5, 5]];
</pre>
<p>To bind an else expression to a specific if, it's possible to use parenthesis.
</p>
<pre>// even numbers are dropped, multiples of 4 are substituted by -1 
echo([for(i=[0:10]) if(i%2==0) (if(i%4==0) -1 ) else i]);
// ECHO: [-1, 1, 3, -1, 5, 7, -1, 9]

// odd numbers are dropped, multiples of 4 are substituted by -1 
echo([for(i=[0:10]) if(i%2==0) if(i%4==0) -1 else i]);
// ECHO: [-1, 2, -1, 6, -1, 10]
</pre>
<h4>let</h4>
<p>The let element allows sequential assignment of variables inside a list comprehension definition.
</p>
<dl><dt>[ for (i = list) let (assignments) a ]</dt></dl>
<p><i>Example</i>
</p>
<pre>list = [ for (a = [ 1 : 4 ]) let (b = a*a, c = 2 * b) [ a, b, c ] ];
echo(list); // ECHO: [[1, 1, 2], [2, 4, 8], [3, 9, 18], [4, 16, 32]]
</pre>
<h3>Nested loops</h3>
<p>There are different ways to define nested loops. Defining multiple loop variables inside one for element and multiple for elements produce both flat result lists. To generate nested result lists an additional [ ] markup is required.
</p>
<pre>// nested loop using multiple variables
flat_result1 = [ for (a = [ 0 : 2 ], b = [ 0 : 2 ]) a == b ? 1 : 0 ];
echo(flat_result1); // ECHO: [1, 0, 0, 0, 1, 0, 0, 0, 1]
</pre>
<p><br/>
</p>
<pre>// nested loop using multiple for elements
flat_result2 = [ for (a = [ 0 : 2 ]) for (b = [0 : 2])  a == b ? 1 : 0 ];
echo(flat_result2); // ECHO: [1, 0, 0, 0, 1, 0, 0, 0, 1]
</pre>
<p><br/>
</p>
<pre>// nested loop to generate a bi-dimensional matrix
identity_matrix = [ for (a = [ 0 : 2 ]) [ for (b = [ 0 : 2 ]) a == b ? 1 : 0 ] ];
echo(identity_matrix); // ECHO: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
</pre>
<p><br/>
</p>
<h3>Advanced Examples</h3>
<p>This chapter lists some advanced examples, useful idioms and use-cases for the list comprehension syntax.
</p>
<h4>Generating vertices for a polygon</h4>
<div class="thumb tright"><div class="thumbinner" style="width:222px;"><a class="image" href="./imgs/220px-OpenSCAD-ellipse.png"><img alt="" class="thumbimage" data-file-height="360" data-file-width="550" decoding="async" height="144" src="./imgs/220px-OpenSCAD-ellipse.png" width="220"/></a>  <div class="thumbcaption">Result</div></div></div>
<p>Using list comprehension, a parametric equation can be calculated at a number of points to approximate many curves, such as the following example for an ellipse (using <a href="2D_Primitives.html#polygon" title="OpenSCAD User Manual/2D Primitives">polygon()</a>):
</p>
<pre>sma = 20;  // semi-minor axis
smb = 30;  // semi-major axis

polygon(
    [ for (a = [0 : 5 : 359]) [ sma * sin(a), smb * cos(a) ] ]
);
</pre>
<p><br clear="all"/>
</p>
<h4>Flattening a nested vector</h4>
<p>List comprehension can be used in a user-defined function to perform tasks on or for vectors.  Here is a user-defined function that flattens a nested vector.
</p>
<pre>// input : nested list
// output : list with the outer level nesting removed
function flatten(l) = [ for (a = l) for (b = a) b ] ;

nested_list = [ [ 1, 2, 3 ], [ 4, 5, 6 ] ];
echo(flatten(nested_list)); // ECHO: [1, 2, 3, 4, 5, 6]
</pre>
<h4>Sorting a vector</h4>
<p>Even a complicated algorithm <a class="extiw" href="https://en.wikipedia.org/wiki/Quicksort" title="w:Quicksort">Quicksort</a> becomes doable with for(), if(), let() and <a href="The_OpenSCAD_Language.html#Recursive_function_calls" title="OpenSCAD User Manual/The OpenSCAD Language">recursion</a>:
</p>
<pre>// input : list of numbers
// output : sorted list of numbers
function quicksort(arr) = !(len(arr)&gt;0) ? [] : let(
    pivot   = arr[floor(len(arr)/2)],
    lesser  = [ for (y = arr) if (y  &lt; pivot) y ],
    equal   = [ for (y = arr) if (y == pivot) y ],
    greater = [ for (y = arr) if (y  &gt; pivot) y ]
) concat(
    quicksort(lesser), equal, quicksort(greater)
);

// use seed in rands() to get reproducible results
unsorted = [for (a = rands(0, 10, 6, 3)) ceil(a)];
echo(unsorted); // ECHO: [6, 1, 8, 9, 3, 2]
echo(quicksort(unsorted)); // ECHO: [1, 2, 3, 6, 8, 9]
</pre>
<h4>Selecting elements of a vector</h4>
<p>select() performs selection and reordering of elements into a new vector. 
</p>
<pre>function select(vector, indices) = [ for (index = indices) vector[index] ];
   
vector1 =   [[0,0],[1,1],[2,2],[3,3],[4,4]];
selector1 = [4,0,3];
vector2 =   select(vector1,selector1);    // [[4, 4], [0, 0], [3, 3]]
vector3 =   select(vector1,[0,2,4,4,2,0]);// [[0, 0], [2, 2], [4, 4],[4, 4], [2, 2], [0, 0]]
// range also works as indices
vector4 =   select(vector1, [4:-1:0]);    // [[4, 4], [3, 3], [2, 2], [1, 1], [0, 0]]
</pre>
<h4>Concatenating two vectors</h4>
<p>Using indices:
</p>
<pre>function cat(L1, L2) = [for (i=[0:len(L1)+len(L2)-1]) 
                        i &lt; len(L1)? L1[i] : L2[i-len(L1)]] ;

echo(cat([1,2,3],[4,5])); //concatenates two OpenSCAD lists [1,2,3] and [4,5], giving [1, 2, 3, 4, 5]
</pre>
<p>Without using indices:
</p>
<pre>function cat(L1, L2) = [for(L=[L1, L2], a=L) a];

echo(cat([1,2,3],[4,5])); //concatenates two OpenSCAD lists [1,2,3] and [4,5], giving [1, 2, 3, 4, 5]
</pre>




</div><footer class="mw-body" style="font-size:13px;color:darkgray;text-align:center;margin-bottom:-1px">
	From the WikiBooks article <a href="https://en.wikibooks.org/wiki/OpenSCAD_User_Manual/List_Comprehensions" style="color:black">List Comprehensions</a> 
	(provided under <a href="https://creativecommons.org/licenses/by-sa/3.0/" style="color:black">
	CC-BY-SA-3.0</a>)</footer></body></html>